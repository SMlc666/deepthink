document.addEventListener('DOMContentLoaded', function() { // --- DOM Element Selectors --- const form = document.getElementById('problem-form'); const problemInput = document.getElementById('problem-input'); const solutionsInput = document.getElementById('solutions-input'); const modeSelect = document.getElementById('mode-select'); const submitButton = document.getElementById('submit-button'); const statusMessage = document.getElementById('status-message'); const resultsContainer = document.getElementById('results-container'); const graphContainer = document.getElementById('graph-container'); const treeContainer = document.getElementById('tree-container'); const detailsView = document.getElementById('details-view'); const detailsPlaceholder = document.getElementById('details-placeholder'); const detailsContent = document.getElementById('details-content'); const detailsTitle = document.getElementById('details-title'); const detailsBody = document.getElementById('details-body'); const usageSummaryContainer = document.getElementById('usage-summary-container'); const usageSummaryContent = document.getElementById('usage-summary-content'); const finalReviewContainer = document.getElementById('final-review-container'); const finalReviewContent = document.getElementById('final-review-content'); const historyList = document.getElementById('history-list'); // --- Mermaid.js Initialization --- mermaid.initialize({ startOnLoad: false, theme: 'base', securityLevel: 'loose' }); // --- State Management --- let nodeContents = new Map(); let nodes = new Map(); let selectedNodeId = null; let currentEventSource = null; let fullHistory = []; // --- Helper Functions --- function getSafeTitle(title, nodeId) { const MAX_TITLE_LENGTH = 50; let displayTitle = (typeof title === 'string' && title) ? title : String(nodeId || ''); if (displayTitle.length > MAX_TITLE_LENGTH) { displayTitle = displayTitle.substring(0, MAX_TITLE_LENGTH) + '...'; } // Correctly escape quotes for Mermaid return displayTitle.replace(/"/g, '#quot;'); } // --- Main Form Submission Logic --- form.addEventListener('submit', async function(event) { event.preventDefault(); const problem = problemInput.value.trim(); if (!problem) { alert('请输入您想解决的问题。'); return; } startNewRun({ problem: problem, solutions: solutionsInput.value, mode: modeSelect.value }); }); function startNewRun(params) { resetUI(); const urlParams = new URLSearchParams({ problem: params.problem, solutions: params.solutions, mode: params.mode, verbose: 'true' }); const url = `/run?${urlParams.toString()}`; currentEventSource = new EventSource(url); let liveUpdates = []; currentEventSource.onmessage = function(event) { try { const update = JSON.parse(event.data); liveUpdates.push(update); const { nodeId, title, content, event: eventType } = update; if (!nodeId) return; // --- Data Population --- if (!nodes.has(nodeId)) { nodes.set(nodeId, { title: title || nodeId, status: 'pending' }); nodeContents.set(nodeId, ''); } const nodeData = nodes.get(nodeId); if (title) nodeData.title = title; let status = nodeData.status; switch (eventType) { case 'progress': status = 'progress'; break; case 'completed': status = 'completed'; break; case 'failed': status = 'failed'; break; case 'chunk': status = 'progress'; const currentContent = nodeContents.get(nodeId) || ''; nodeContents.set(nodeId, currentContent + content); if (nodeId === 'final_review') { finalReviewContainer.style.display = 'block'; finalReviewContent.innerHTML = marked.parse(nodeContents.get(nodeId)); } break; } nodeData.status = status; if (content && eventType !== 'chunk') nodeContents.set(nodeId, content); // --- Live Rendering --- // For live runs, always use graph view as they are unlikely to exceed the limit in real-time. reconstructGraphFromHistory(liveUpdates, true); if (selectedNodeId === nodeId) { updateDetailsView(nodeId); } if (eventType === 'completed' && nodeId === 'root') { handleCompletionEvents(nodeId, content); } } catch (e) { console.error("Error processing SSE message:", e); } }; currentEventSource.onerror = function(err) { console.error('EventSource failed:', err); handleStreamEnd(false, '与服务器的连接丢失。请检查后台服务是否正在运行，然后重试。'); }; } // --- UI and Rendering Functions --- function resetUI() { if (currentEventSource) { currentEventSource.close(); currentEventSource = null; } submitButton.disabled = true; submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 正在思考...'; statusMessage.style.display = 'block'; statusMessage.className = 'status-message status-thinking'; statusMessage.textContent = 'AI正在处理您的问题，请稍候...'; resultsContainer.style.display = 'block'; graphContainer.innerHTML = ''; graphContainer.style.display = 'none'; treeContainer.innerHTML = ''; treeContainer.style.display = 'none'; detailsPlaceholder.style.display = 'flex'; detailsContent.style.display = 'none'; finalReviewContainer.style.display = 'none'; finalReviewContent.innerHTML = ''; usageSummaryContainer.style.display = 'none'; usageSummaryContent.textContent = ''; resetGraphState(); } function renderGraph(definition) { try { graphContainer.style.display = 'block'; treeContainer.style.display = 'none'; const sanitizedGraph = definition.replace(/</g, '&lt;').replace(/>/g, '&gt;'); graphContainer.innerHTML = `<div class="mermaid">${sanitizedGraph}</div>`; mermaid.run({ nodes: document.querySelectorAll('.mermaid') }); } catch (e) { console.error("Mermaid rendering error:", e); graphContainer.innerText = "渲染图形时出错。"; } } function renderTreeView(updates) { graphContainer.style.display = 'none'; treeContainer.style.display = 'block'; treeContainer.innerHTML = ''; const nodeElements = new Map(); updates.forEach(update => { const { nodeId } = update; if (!nodeId || !nodes.has(nodeId)) return; const nodeData = nodes.get(nodeId); const nodeElement = document.createElement('div'); nodeElement.className = 'tree-node'; nodeElement.dataset.id = nodeId; const statusClass = `status-${nodeData.status}`; const iconClass = { completed: 'fa-check-circle', failed: 'fa-times-circle', progress: 'fa-spinner fa-spin' }[nodeData.status] || 'fa-question-circle'; nodeElement.innerHTML = ` <div class="node-title"> <i class="fas ${iconClass} status-icon ${statusClass}"></i> <span>${getSafeTitle(nodeData.title, nodeId)}</span> </div> `; nodeElement.addEventListener('click', (e) => { e.stopPropagation(); handleNodeClick(nodeId); }); nodeElements.set(nodeId, nodeElement); }); updates.forEach(update => { const { nodeId, parentId } = update; if (!nodeId || !nodeElements.has(nodeId)) return; const nodeElement = nodeElements.get(nodeId); const parentElement = nodeElements.get(parentId); if (parentElement) { let childrenContainer = parentElement.querySelector('.tree-node-children'); if (!childrenContainer) { childrenContainer = document.createElement('div'); childrenContainer.className = 'tree-node-children'; parentElement.appendChild(childrenContainer); } childrenContainer.appendChild(nodeElement); } else { treeContainer.appendChild(nodeElement); } }); } function updateDetailsView(nodeId) { const nodeData = nodes.get(nodeId); const content = nodeContents.get(nodeId); if (!nodeData) return; detailsPlaceholder.style.display = 'none'; detailsContent.style.display = 'block'; detailsTitle.innerText = nodeData.title; if (content && content.trim().length > 0) { try { const jsonContent = JSON.parse(content); detailsBody.innerHTML = `<pre><code>${JSON.stringify(jsonContent, null, 2)}</code></pre>`; } catch (e) { detailsBody.innerHTML = marked.parse(content); } } else { detailsBody.innerHTML = '<p><em>此节点没有详细内容。</em></p>'; } } window.handleNodeClick = (clickedNodeId) => { if (!clickedNodeId || !nodes.has(clickedNodeId)) return; if (selectedNodeId) { const oldGraphNode = graphContainer.querySelector(`#${selectedNodeId}`); if (oldGraphNode) oldGraphNode.classList.remove('selected'); const oldTreeNode = treeContainer.querySelector(`[data-id="${selectedNodeId}"]`); if (oldTreeNode) oldTreeNode.classList.remove('selected'); } const newGraphNode = graphContainer.querySelector(`#${clickedNodeId}`); if (newGraphNode) newGraphNode.classList.add('selected'); const newTreeNode = treeContainer.querySelector(`[data-id="${clickedNodeId}"]`); if (newTreeNode) newTreeNode.classList.add('selected'); selectedNodeId = clickedNodeId; updateDetailsView(clickedNodeId); }; function handleCompletionEvents(nodeId, content) { if (nodeId === 'root') { handleStreamEnd(true, '任务处理完成！'); loadHistory(); try { const usageMatch = content.match(/Token使用情况:\s*(\{[\s\S]*\})/); if (usageMatch && usageMatch[1]) { const usageData = JSON.parse(usageMatch[1]); usageSummaryContent.textContent = JSON.stringify(usageData, null, 2); usageSummaryContainer.style.display = 'block'; } } catch (e) { console.error("Could not parse token usage summary:", e); } } } function handleStreamEnd(isSuccess, message) { statusMessage.className = `status-message ${isSuccess ? 'status-success' : 'status-error'}`; statusMessage.textContent = message; submitButton.disabled = false; submitButton.innerHTML = `<i class="fas fa-paper-plane"></i> ${isSuccess ? '重新开始' : '再次尝试'}`; if (currentEventSource) { currentEventSource.close(); currentEventSource = null; } } // --- History Functions --- async function loadHistory() { try { const response = await fetch('/history'); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); fullHistory = await response.json(); renderHistory(); } catch (error) { console.error("Could not fetch history:", error); historyList.innerHTML = '<p class="error">无法加载历史记录。</p>'; } } function renderHistory() { historyList.innerHTML = ''; if (fullHistory.length === 0) { historyList.innerHTML = '<p>暂无历史记录。</p>'; return; } fullHistory.forEach(entry => { const item = document.createElement('div'); item.className = 'history-item'; item.dataset.id = entry.id; const statusIcon = entry.status === 'completed' ? 'fa-check-circle status-completed' : entry.status === 'failed' ? 'fa-times-circle status-failed' : 'fa-spinner fa-spin status-running'; item.innerHTML = ` <div class="history-item-header"> <i class="fas ${statusIcon} status-icon"></i> <span>${entry.source === 'web' ? '网页' : 'CLI'}</span> </div> <p class="history-item-problem" title="${entry.problem}">${entry.problem}</p> <div class="history-item-meta"> <span>${new Date(entry.timestamp).toLocaleString()}</span> <span>${entry.mode} / ${entry.solutions}</span> </div> <div class="history-item-actions"> <button class="rerun-btn"><i class="fas fa-redo"></i> 重跑</button> <button class="view-btn"><i class="fas fa-eye"></i> 查看</button> </div> `; historyList.appendChild(item); }); } historyList.addEventListener('click', (e) => { const button = e.target.closest('button'); if (!button) return; const item = e.target.closest('.history-item'); const entryId = item.dataset.id; const entry = fullHistory.find(h => h.id === entryId); if (!entry) return; if (button.classList.contains('rerun-btn')) { problemInput.value = entry.problem; solutionsInput.value = entry.solutions; modeSelect.value = entry.mode; startNewRun(entry); } else if (button.classList.contains('view-btn')) { viewHistoryEntry(entry); } }); function viewHistoryEntry(entry) { resetUI(); handleStreamEnd(true, '查看历史记录'); if (entry.final_review) { finalReviewContainer.style.display = 'block'; finalReviewContent.innerHTML = marked.parse(entry.final_review); } if (entry.usage) { usageSummaryContainer.style.display = 'block'; usageSummaryContent.textContent = JSON.stringify(entry.usage, null, 2); } if (entry.graph_data) { reconstructGraphFromHistory(entry.graph_data); } else { graphContainer.style.display = 'block'; graphContainer.innerHTML = '<p>历史记录不包含流程图。</p>'; } detailsPlaceholder.style.display = 'flex'; detailsContent.style.display = 'none'; } function reconstructGraphFromHistory(updates, forceGraphView = false) { const MAX_NODES_FOR_GRAPH = 200; resetGraphState(); // First pass: populate global data stores (nodes, nodeContents) updates.forEach(update => { const { nodeId, title, content, event: eventType } = update; if (!nodeId) return; if (!nodes.has(nodeId)) { nodes.set(nodeId, { title: title || nodeId, status: 'pending' }); nodeContents.set(nodeId, ''); } const nodeData = nodes.get(nodeId); if (title) nodeData.title = title; let status = nodeData.status; switch (eventType) { case 'progress': case 'chunk': status = 'progress'; break; case 'completed': status = 'completed'; break; case 'failed': status = 'failed'; break; } nodeData.status = status; if (eventType === 'chunk') { const currentContent = nodeContents.get(nodeId) || ''; nodeContents.set(nodeId, currentContent + (content || '')); } else if (content) { nodeContents.set(nodeId, content); } }); // Second pass: decide which view to render if (!forceGraphView && updates.length > MAX_NODES_FOR_GRAPH) { renderTreeView(updates); } else { // --- Graph Reconstruction with Subgraphs --- const parentOf = new Map(); const allNodeIds = new Set(); updates.forEach(u => { if (!u.nodeId) return; allNodeIds.add(u.nodeId); // Record parent-child relationship regardless of arrival order. if (u.parentId) { parentOf.set(u.nodeId, u.parentId); } }); const solutionNodes = new Set(); const nodesBySolution = new Map(); const nonSolutionNodes = []; for (const nodeId of allNodeIds) { let solutionRoot = null; // Check if the node itself is a solution root if (nodeId.startsWith('solution_') || nodeId.startsWith('math_strategy_')) { solutionRoot = nodeId; } else { // Otherwise, traverse up to find its solution root let p = nodeId; while ((p = parentOf.get(p))) { if (p.startsWith('solution_') || p.startsWith('math_strategy_')) { solutionRoot = p; break; } } } if (solutionRoot) { solutionNodes.add(solutionRoot); if (!nodesBySolution.has(solutionRoot)) { nodesBySolution.set(solutionRoot, []); } nodesBySolution.get(solutionRoot).push(nodeId); } else { nonSolutionNodes.push(nodeId); } } } let mermaidDef = 'graph TD;\n'; // Define nodes that are outside any solution subgraph nonSolutionNodes.forEach(nodeId => { if (solutionNodes.has(nodeId)) return; // Should not happen, but for safety const nodeData = nodes.get(nodeId); if (!nodeData) return; const safeTitle = getSafeTitle(nodeData.title, nodeId); mermaidDef += `    ${nodeId}[